## 编译器

​	工作许年后才渐渐地发现大学的专业内容是多么的重要。头几年，我的认知只是停留在使用各种工具上，看谁能熟练、快速地使用工具完成任务，谁就牛逼。随着工作的不断深入和业务的成长，我那所熟练的工具搭建起来的系统遇到了这样那样的瓶颈。当我自以为豪的系统首次碰到了我认知以外的问题的时候，我的内心是不安、是害怕。因为我没有把握定位出问题，并优化它，等待的是上级领导的追责。

​	所以，应用程序所依赖的第三方工具包、运行环境所使用的操作系统、远程负责状态维护的数据库，你都必须要了解他，熟知他。当碰到问题时，你才有十足的把握判断的出来是哪一方面出了问题，需要什么手段去优化它。比如，操作系统知识方面：应用层读取磁盘文件的时候，上层到系统调用层，再到操作系统内核，最终到磁盘控制器和磁盘他们都是怎么运作的？机器出现超负荷运转时候，到底是IO（磁盘、网络）还是CPU出现了瓶颈？若让你加机器保证负载，你如何加？又比如数据库方面：不同db采用的索引的算法是什么？为什么OLTP在大数据量下不建议用join？join连接算法是怎么样，时间和空间复杂度是多少？为什么map-join效率高？Mysql Innodb聚集索引有什么优势？wal/statement log/binlog作用各是什么？等等。。。

​	基于上面原因，我打算重新学习一下专业知识，采用的方式从上到下——从实践到理论。相关内容知识：

- Java编译器的实现
- SQL关系数据数据库的实现
- 操作系统实现

写作的开篇之作——《Java编译器的实现》

### Day_01 基础理论

​	一个编译器的各个步骤如下说明：

|     Module      |    Input    |            Output             |
| :-------------: | :---------: | :---------------------------: |
|  Lexer(词法分析器)   |  Text(字符流)  |      Tokens(符号流或词法单元序列)       |
|  Parser(语法解析器)  | Tokens(符号流) | AST(Abstract Syntax Tree) 语法树 |
| Analyzer(语义分析器) |     AST     |      中间代码（JVM Bytecode）       |
|      代码优化器      |    中间代码     |           优化后的中间代码            |
|      代码生成器      |  优化后的中间代码   |             机器代码              |
|     机器代码优化器     |    机器代码     |           优化后的机器代码            |

​	在我们的任务中，需要完成前面三个模块（Lexer、Parser、Analyzer）

- Lexer

  词法分析器，又称为扫描器。他读入组成源程序的字符流，并且将他们组织成有意义的**词素（lexeme）序列**。对于每一个词素，词法分析器产生如下信息的**词法单元（token）或词法符号**作为输出：

  > \<token-name, attribute-value> 或者其他比如Antlr4形式

  举例文法`Hello.g4`

  ```JAVA
  grammar Hello; // 定义一个名为Hello的文法
  r : 'hello' ID ; // 匹配关键字hello和后面的标识符号
  ID : [a-z]+ ; // 匹配小写字母组成的标识符号
  WS : [ \t\r\n]+ -> skip ; // 过滤空格、Tab、换行以及 \r (Windows)
  ```

  Text字符流：

  > hello parrt
  >
  > Ctrl+D或者ctrl+Z

  Lexer生成的符号表：

  > ```g4
  > T__0=1
  > ID=2
  > WS=3
  > 'hello'=1
  > ```
  >
  > 词法符号流列表的全部信息：
  >
  > ```g4
  > [@0,0:4='hello',<1>,1:0]
  > [@1,6:10='parrt',<2>,1:6]
  > [@2,12:11='<EOF>',<-1>,2:0]
  > ```
  >
  > hello： 识别为一个词素，映射成词法单元为：[@0,0:4='hello',<1>,1:0]
  >
  > parrt： 识别为一个词素，映射成词法单元为：[@1,6:10='parrt',<2>,1:6]
  >
  > Ctrl+D或者ctrl+Z: 识别为一个词素，映射成词法单元为：[@2,12:11='<EOF>',<-1>,2:0]

     说明下hello的词素映射成词法单元的方法，中间以逗号隔开：

  - `@0`：词素位于第一个位置（由0下标开始）
  - `0:4='hello'`: 由第0~4个字符构成，内容为hello
  - `<1>`：属于文法中的类型1（ID）
  - `1:0`表明位于第一行、第0个位置处。

  ​

- Parser

  组织了词法单元序列的运算结构，语法树决定了词法单元的运算顺序，有助于对程序设计语言结构的翻译。

- Analyzer（这里举例为JVM Bytecode代码）

  使用语法树和符号（词素名称）表中的信息来检查源程序文件是否与语言定义的语义一致。语义分析一个重要的部分是类型分析，编译器检查每个运算符是否符合要求。比如数组下标是不是写成负数的？最终语义分析器将源程序文件成`.class`的字节码。



### Day_02 简单的Java编译器实现



#### 任务

​	将下面的Java代码，使用自己的编译器生成`.class`文件，并使用执行起来。

```java
int a = 9;
int fact(int x) {
  if (x==0) {
    return 1;
  }
  return x * fact(x-1);
}
```

#### 解决步骤

**1、生成文法**

```gas
grammar JavaBlock;

file
    :   (functionDecl | varDecl)+
    ;

varDecl
    : type ID ('=' expr)? ';'
    ;

type
    : 'float' | 'int' | 'void'; // 用户定义的类型

expr
    :   ID '(' exprList? ')'
    |   expr '[' expr ']'
    |   '-' expr
    |   '!' expr
    |   expr '*' expr
    |   expr '==' expr
    |   expr ('+'|'-') expr
    |   ID
    |   INT
    |   '(' expr ')'
    ;

exprList
    :   expr (',' expr)*
    ;

functionDecl
    :   type ID '(' formalParameters? ')' block
    ;

formalParameters
    :   formalParameter (',' formalParameter)*
    ;

formalParameter
    :   type ID
    ;

block
    :   '{' stat* '}'
    ;

stat
    :   block
    |   varDecl
    |   'if' expr  stat  ('else' stat)?
    |   'return' expr? ';'
    |   expr '=' expr ';'
    |   expr ';'
    ;

ID  :   [a-zA-Z]+   ;
INT :   [0-9]+  ;
```

**2、生成词法单元**

```gas
T__0=1
T__1=2
T__2=3
T__3=4
T__4=5
T__5=6
T__6=7
T__7=8
T__8=9
T__9=10
T__10=11
T__11=12
T__12=13
T__13=14
T__14=15
T__15=16
T__16=17
T__17=18
T__18=19
T__19=20
ID=21
INT=22
'='=1
';'=2
'float'=3
'int'=4
'void'=5
'('=6
')'=7
'['=8
']'=9
'-'=10
'!'=11
'*'=12
'=='=13
'+'=14
','=15
'{'=16
'}'=17
'if'=18
'else'=19
'return'=20
```

**3、生成语法树**

​	![JavaBlock](JavaBlock.png)

**4、遍历语法树，语义解析**

**5、生成字节码**

**6、将字节码写入文件，生成`.class`文件**

**7、运行字节码，展示结果**